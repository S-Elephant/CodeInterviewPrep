[
	{
		"type": "multiple_choice",
		"question": "What is C# primarily known as?",
		"answers": [
		"A scripting language for web development",
		"A statically-typed, object-oriented programming language developed by Microsoft",
		"A markup language for creating documents",
		"A database query language"
		],
		"correctIndices": [1],
		"explanation": "C# is a statically-typed, object-oriented language developed by Microsoft as part of the .NET initiative, combining principles from C++ and Java.",
		"tags": ["c#", "fundamental", "theory"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "text_input",
		"question": "In object-oriented programming, what is an instance of a class called?",
		"correctAnswers": ["object", "an object", "class instance", "instance"],
		"explanation": "An object is a runtime instance of a class that contains actual values rather than just the structure defined by the class.",
		"tags": ["c#", "oop", "fundamental", "theory"],
		"difficulty": "easy",
		"importance": "important"
	},
	{
		"type": "multiple_choice",
		"question": "What keyword is used to create an object instance in C#?",
		"answers": [
		"create",
		"new",
		"object",
		"instance"
		],
		"correctIndices": [1],
		"explanation": "The 'new' keyword allocates memory and creates an instance of a class, invoking its constructor.",
		"tags": ["c#", "oop", "fundamental"],
		"difficulty": "easy",
		"importance": "rare"
	},
	{
		"type": "multi_select",
		"question": "What are the main purposes of serialization?",
		"answers": [
		"To convert an object's state to a transmittable format",
		"To improve code execution speed",
		"To enable object persistence in storage",
		"To reduce the number of classes in a program",
		"To facilitate network communication"
		],
		"correctIndices": [0, 2, 4],
		"explanation": "Serialization converts objects to byte streams for storage (e.g., files/databases) or transmission (e.g., web APIs). It doesn't optimize execution speed or reduce code.",
		"tags": ["c#", "serialization", "fundamental", "theory"],
		"difficulty": "easy",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is the difference between 'break' and 'continue' in loops?",
		"answers": [
		"'break' exits the entire loop, 'continue' skips to the next iteration",
		"'break' skips to the next iteration, 'continue' exits the loop",
		"They are functionally identical",
		"'break' works in for-loops, 'continue' works in while-loops"
		],
		"correctIndices": [0],
		"explanation": "'break' terminates the loop completely, while 'continue' only skips the current iteration and proceeds with the next one.",
		"tags": ["c#", "fundamental"],
		"difficulty": "easy",
		"importance": "standard"
	},
	{
		"type": "multi_select",
		"question": "Which steps are part of C# code compilation?",
		"answers": [
		"Source code compiled to managed code (CIL)",
		"Direct compilation to machine code",
		"CLR loading and JIT compilation",
		"Assembly execution by CLR",
		"Automatic code optimization by the IDE"
		],
		"correctIndices": [0, 2, 3],
		"explanation": "C# compilation:<br>1) Source → CIL<br>2) Metadata+IL combined into assembly<br>3) CLR loads assembly<br>4) JIT compiles to native code during execution.<br><br>IDE optimization isn't part of formal compilation.",
		"tags": ["c#", "fundamental"],
		"difficulty": "hard",
		"importance": "important"
	},
	{
		"type": "multiple_choice",
		"question": "What does CLR stand for in .NET?",
		"answers": [
		"Common Language Runtime",
		"Compiled Library Registry",
		"Core Language Reference",
		"Centralized Load Router"
		],
		"correctIndices": [0],
		"explanation": "The Common Language Runtime (CLR) is .NET's execution engine handling memory management, JIT compilation, exception handling, and security.",
		"tags": [".net", "fundamental", "theory"],
		"difficulty": "easy",
		"importance": "standard"
	},
	{
		"type": "text_input",
		"question": "What is the intermediate code generated by C# compilation called?",
		"correctAnswers": ["CIL", "Common Intermediate Language", "MSIL", "Microsoft Intermediate Language"],
		"explanation": "C# compiles to CIL (Common Intermediate Language), formerly called MSIL, which is then JIT-compiled to native code by the CLR.",
		"tags": ["c#", "theory"],
		"difficulty": "medium",
		"importance": "very rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is the key difference between 'finally' blocks and 'finalize' in C#?",
		"answers": [
		"'finally' is used in garbage collection, while 'finalize' handles exceptions",
		"'finally' ensures code execution after try/catch, while 'finalize' is a destructor for cleanup before GC",
		"They are identical and interchangeable",
		"'finalize' is a C# keyword, while 'finally' is a .NET Framework method"
		],
		"correctIndices": [1],
		"explanation": "Critical differences:<br><br>✅ <b>finally</b>:<br>- Part of try/catch/finally exception handling<br>- <i>Guaranteed</i> to execute (unless process termination)<br>- Used for resource cleanup like closing files<br><br>✅ <b>finalize</b>:<br>- Defined via destructor syntax <code>~ClassName()</code><br>- Called <i>non-deterministically</i> by garbage collector<br>- Only for unmanaged resource fallback cleanup<br><br>Modern C# prefers <code>IDisposable</code> pattern over finalizers.",
		"tags": ["c#", "fundamental"],
		"difficulty": "medium",
		"importance": "very rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is the key difference between 'readonly' and 'const' in C#?",
		"answers": [
		"'const' values can be modified at runtime, while 'readonly' cannot",
		"'readonly' fields are evaluated at compile-time, while 'const' is evaluated at runtime",
		"'const' is compile-time constant, while 'readonly' can be set at runtime (e.g., in constructors)",
		"They are identical and interchangeable"
		],
		"correctIndices": [2],
		"explanation": "Critical differences:<br><br>🔹 <b>const</b>:<br>- Must be initialized at declaration<br>- Evaluated at <i>compile-time</i><br>- Implicitly <code>static</code><br>- Only works with primitive types<br><br>🔹 <b>readonly</b>:<br>- Can be initialized in constructor<br>- Evaluated at <i>runtime</i><br>- Can be instance or static<br>- Works with any data type<br><br>Example:<br><code>const int Max = 100; // Compile-time<br>readonly DateTime Created = DateTime.Now; // Runtime</code>",
		"tags": ["c#", "fundamental"],
		"difficulty": "medium",
		"importance": "very rare"
	},
	{
		"type": "multiple_choice",
		"question": "Which component performs Just-In-Time compilation in .NET?",
		"answers": [
		"The C# compiler (csc)",
		"The Common Language Runtime (CLR)",
		"The Global Assembly Cache (GAC)",
		"The NuGet package manager"
		],
		"correctIndices": [1],
		"explanation": "The CLR's JIT compiler converts CIL to native machine code at runtime, optimizing for the current execution environment.",
		"tags": [".net", "theory"],
		"difficulty": "medium",
		"importance": "very rare"
	},
	{
		"type": "multiple_choice",
		"question": "Which of these are valid parameter types in C#?",
		"answers": [
		"value, output, ref",
		"input, output, reference",
		"const, var, dynamic",
		"in, out, ref"
		],
		"correctIndices": [3],
		"explanation": "C# has four main parameter modifiers:<br><br>1) <b>value</b>: Default (no keyword needed)<br>2) <b>ref</b>: Pass by reference (must be initialized)<br>3) <b>out</b>: Output parameter (doesn't require initialization)<br>4) <b>in</b>: Readonly reference (C# 7.2+)<br><br>'output' is not a keyword - the correct term is 'out'.",
		"tags": ["c#", "fundamental"],
		"difficulty": "easy",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is an interface in C#?",
		"answers": [
		"A class that can only contain method implementations",
		"A contract that defines what methods a class must implement",
		"A special type of abstract class with some implemented methods",
		"A base class that can be instantiated directly"
		],
		"correctIndices": [1],
		"explanation": "An <b>interface</b> in C#:<br><br>✓ Defines a <i>contract</i> (what methods/properties a class must implement)<br>✓ Contains only declarations (no implementations)<br>✓ All members are implicitly public and abstract<br>✓ A class can implement multiple interfaces<br><br>Example:<br><code>interface ILogger { void Log(string message); }</code>",
		"tags": ["c#", "fundamental", "theory"],
		"difficulty": "easy",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is an abstract class in C#?",
		"answers": [
		"A class that can be instantiated directly",
		"A class that must be inherited and can contain both implemented and unimplemented members",
		"A class that only contains static members",
		"A class marked with the 'virtual' keyword"
		],
		"correctIndices": [1],
		"explanation": "An <b>abstract class</b> in C#:<br><br>✓ Cannot be instantiated directly<br>✓ Can contain both concrete methods (with implementation) and abstract methods (without implementation)<br>✓ Requires derived classes to implement all abstract members<br>✓ Can have constructors, fields, and properties<br><br>Contrast with interfaces (all members abstract) and sealed classes (cannot be inherited).",
		"tags": ["c#", "fundamental"],
		"difficulty": "medium",
		"importance": "rare"
	},
    {
        "type": "multiple_choice",
        "question": "Where is a struct placed in memory?",
        "answers": [
            "Always on the heap",
            "Always on the stack",
            "On the heap when boxed, otherwise stack",
            "Depends on the struct size"
        ],
        "correctIndices": [2],
        "explanation": "Structs are value types and typically live on the stack. However, when boxed (e.g., cast to an object), they're moved to the heap.<br><br>Boxing is the process of converting a value type to the type object or to any interface type implemented by this value type.",
        "tags": ["c#", "memory", "theory", "performance"],
        "difficulty": "medium",
        "importance": "essential"
    },
    {
        "type": "multiple_choice",
        "question": "What is method overloading in programming?",
        "answers": [
            "Creating multiple methods with the same name but different signatures in the same class",
            "Creating methods with different names for similar functionality",
            "Overriding existing methods in a parent class",
            "Making methods run faster by overloading them"
        ],
        "correctIndices": [0],
        "explanation": "Method overloading allows multiple methods in the same class to share the same name but have different parameters (different signatures). The compiler determines which method to call based on overload resolution.",
        "tags": ["c#", "fundamental"],
        "difficulty": "easy",
        "importance": "essential"
    },
    {
        "type": "multiple_choice",
        "question": "What are C# attributes primarily used for?",
        "answers": [
            "Adding declarative information to code elements that can be retrieved at runtime",
            "Improving the performance of methods",
            "Controlling access modifiers of class members",
            "Defining variable types"
        ],
        "correctIndices": [0],
        "explanation": "Attributes in C# provide a way to add declarative metadata to program elements which can then be examined at runtime using reflection.",
        "tags": ["c#", "fundamental"],
        "difficulty": "easy",
        "importance": "standard"
    },
    {
        "type": "multiple_choice",
        "question": "What is the primary difference between Dispose() and Finalize() methods?",
        "answers": [
            "Dispose() releases unmanaged resources while Finalize() doesn't guarantee garbage collection",
            "Finalize() is faster than Dispose()",
            "Dispose() is only for managed resources while Finalize() is for unmanaged",
            "They are identical in function"
        ],
        "correctIndices": [0],
        "explanation": "Dispose() is explicitly called to release unmanaged resources, while Finalize() is called by the garbage collector and doesn't guarantee when or if it will run.",
        "tags": ["c#", "fundamental", "memory"],
        "difficulty": "hard",
        "importance": "important"
    },
    {
        "type": "multiple_choice",
        "question": "Why are namespaces used in C#?",
        "answers": [
            "To organize code and prevent naming conflicts",
            "To improve compilation speed",
            "To make all classes public by default",
            "To automatically garbage collect unused objects"
        ],
        "correctIndices": [0],
        "explanation": "Namespaces help organize code into logical groups and prevent naming collisions between different libraries or components.",
        "tags": ["c#", "fundamental"],
        "difficulty": "easy",
        "importance": "essential"
    },
    {
        "type": "multiple_choice",
        "question": "What is the purpose of Async and Await in C#?",
        "answers": [
            "To enable asynchronous programming that doesn't block the main thread",
            "To make synchronous code run faster",
            "To automatically parallelize all method calls",
            "To prevent multiple threads from accessing shared resources"
        ],
        "correctIndices": [0],
        "explanation": "Async and Await keywords in C# allow for asynchronous programming where operations can execute without blocking the calling thread, improving application responsiveness.",
        "tags": ["c#", "fundamental", "threading"],
        "difficulty": "easy",
        "importance": "essential"
    },
	{
		"type": "multiple_choice",
		"question": "Consider this C# statement: 'Arrays are allocated on the heap and with an array of ints, the ints are unboxed.' Is this statement correct?",
		"answers": [
		"Yes, arrays are always heap-allocated and primitive types like int are never boxed in arrays",
		"No, arrays can sometimes be stack-allocated",
		"No, while arrays are heap-allocated, ints in arrays are boxed",
		"Partially correct - arrays are heap-allocated but boxing depends on usage"
		],
		"correctIndices": [0],
		"explanation": "The statement is <b>fully correct</b> because:<br><br>1) <b>Array allocation</b>: All arrays in C# are reference types (even <code>int[]</code>) and live on the managed heap<br><br>2) <b>Unboxed ints</b></code>: Value types in arrays are stored directly in contiguous memory:<br><code>int[] numbers = new int[3] {1, 2, 3}; // No boxing occurs</code><br><br>Boxing only happens when casting value types to <code>object</code>/interfaces, like:<br><code>object[] boxedNumbers = new object[] {1, 2, 3}; // Boxing occurs here</code>",
		"tags": ["c#", "memory", "theory", "performance"],
		"difficulty": "hard",
		"importance": "very rare"
	},
    {
        "type": "multiple_choice",
        "question": "What is the difference between the heap and the stack in C#?",
        "answers": [
            "Stack is for value types, heap is for reference types",
            "Stack has fixed-size blocks, heap is dynamically allocated",
            "Stack is faster but has limited space, heap is slower but larger",
            "All of the above"
        ],
        "correctIndices": [3],
        "explanation": "The stack stores value types and method calls with fixed-size memory (fast access). The heap stores reference types with dynamic allocation (larger but slower).",
        "tags": ["c#", "memory", "heap", "stack", "theory", "performance"],
        "difficulty": "medium",
        "importance": "rare"
    },
    {
        "type": "multiple_choice",
        "question": "Which C# keyword ensures deterministic resource cleanup?",
        "answers": [
            "finally",
            "using",
            "dispose",
            "gc.Collect()"
        ],
        "correctIndices": [1],
        "explanation": "The 'using' statement automatically calls Dispose() on IDisposable objects when the block exits.",
        "tags": ["c#", "dispose", "resource-management", "theory"],
        "difficulty": "easy",
        "importance": "very rare"
    },
    {
        "type": "text_input",
        "question": "What C# feature allows you to extend existing types without inheritance?",
        "correctAnswers": ["Extension methods", "Extension method", "Extension", "Extensions"],
        "explanation": "Extension methods let you add methods to existing types (e.g., String) without modifying their source code.",
        "tags": ["c#", "extension-method"],
        "difficulty": "medium",
        "importance": "rare"
    },
	{
		"type": "multi_select",
		"question": "Which of these are C# access modifiers?",
		"answers": [
			"public",
			"private",
			"protected",
			"global"
		],
		"correctIndices": [0, 1, 2],
		"explanation": "c# access modifiers include public, private, and protected. 'global' is not a valid access modifier.",
		"tags": ["c#", "access-modifier"],
		"difficulty": "easy",
		"importance": "important"
	},
    {
        "type": "multiple_choice",
        "question": "What is the output of: 'Console.WriteLine(default(int?));'",
        "answers": [
            "0",
            "null",
            "Compiler error",
            "undefined"
        ],
        "correctIndices": [1],
        "explanation": "Nullable<T> defaults to null, unlike non-nullable value types (e.g., default(int) is 0).",
        "tags": ["c#", "nullable", "default"],
        "difficulty": "easy",
        "importance": "important"
    },
    {
        "type": "multiple_choice",
        "question": "Which is NOT a C# collection interface?",
        "answers": [
            "IEnumerable",
            "IQueryable",
            "ICollector",
            "IList"
        ],
        "correctIndices": [2],
        "explanation": "ICollector is used in Azure Functions, not in standard C# collections. The core interfaces are IEnumerable, IList, and IQueryable.",
        "tags": ["c#", "collections", "theory"],
        "difficulty": "hard",
        "importance": "very rare"
    },
    {
        "type": "text_input",
        "question": "What C# 9 feature simplifies immutable object creation?",
        "correctAnswers": ["Records"],
        "explanation": "Records provide value-based equality and immutable properties with minimal boilerplate code (e.g., 'public record Person(string Name)').",
        "tags": ["c#", "records", "immutability"],
        "difficulty": "hard",
        "importance": "very rare"
    },
    {
        "type": "multiple_choice",
        "question": "When does a C# static constructor run?",
        "answers": [
            "When the class is first instantiated",
            "When any static member is accessed",
            "At program startup",
            "Both A and B"
        ],
        "correctIndices": [3],
        "explanation": "Static constructors run automatically before the first instance is created or any static member is accessed.",
        "tags": ["c#", "constructor"],
        "difficulty": "medium",
        "importance": "important"
    },
    {
        "type": "text_input",
        "question": "What is the result of 9 % 2? (Modulus operation)",
        "correctAnswers": ["1", "one"],
        "explanation": "The modulus operator (%) returns the remainder after division. 9 divided by 2 is 4 with a remainder of 1, so 9 % 2 = 1.",
        "tags": ["c#", "math", "operators"],
        "difficulty": "easy",
        "importance": "important"
    },
    {
        "type": "multiple_choice",
        "question": "What is the (??) operator in C#?",
        "answers": [
            "Null-coalescing operator",
            "Ternary operator",
            "Null-conditional operator",
            "Bitwise OR operator"
        ],
        "correctIndices": [2],
        "explanation": "The ?? operator returns the left-hand operand if it's not null, otherwise it returns the right-hand operand.",
        "tags": ["c#", "operators", "null"],
        "difficulty": "easy",
        "importance": "important"
    },
    {
        "type": "multiple_choice",
        "question": "What is a strongly typed language?",
        "answers": [
            "A language where types are checked at runtime",
            "A language where types are explicitly declared and checked at compile-time",
            "A language that only uses strong encryption",
            "A language with no type checking"
        ],
        "correctIndices": [1],
        "explanation": "c# is strongly typed, meaning variables must be declared with specific types and type mismatches are caught at compile-time.",
        "tags": ["c#", "types", "language-features", "theory"],
        "difficulty": "easy",
        "importance": "important"
    },
    {
        "type": "multiple_choice",
        "question": "What does the 'protected internal' access modifier do in C#?",
        "answers": [
            "Accessible only within the same assembly",
            "Accessible only to derived classes",
            "Accessible to derived classes OR classes in the same assembly",
            "Accessible to any class"
        ],
        "correctIndices": [2],
        "explanation": "'protected internal' means the member is accessible from derived classes (protected) OR from any class in the same assembly (internal).",
        "tags": ["c#", "access-modifier"],
        "difficulty": "medium",
        "importance": "rare"
    },
    {
        "type": "multiple_choice",
        "question": "What does the 'private protected' access modifier do in C#?",
        "answers": [
            "Accessible only within the same class",
            "Accessible to derived classes in the same assembly",
            "Accessible to any class in the same assembly",
            "Accessible to derived classes in any assembly"
        ],
        "correctIndices": [1],
        "explanation": "'private protected' means the member is accessible only to derived classes that are in the same assembly.",
        "tags": ["c#", "access-modifier", "theory"],
        "difficulty": "medium",
        "importance": "rare"
    },
    {
        "type": "multiple_choice",
        "question": "Can a single for-loop initialize and increment multiple variables in C#?",
        "answers": [
            "Yes, by separating them with commas",
            "No, only one variable is allowed",
            "Only if they're the same type",
            "Only in while loops"
        ],
        "correctIndices": [0],
        "explanation": "c# allows multiple variables in for-loops (e.g., for(int i = 0, j = 10; i < j; i++, j--)).",
        "tags": ["c#", "loops", "syntax"],
        "difficulty": "easy",
        "importance": "rare"
    },
    {
        "type": "multiple_choice",
        "question": "Can 'out' and 'ref' parameters be used to overload methods in C#?",
        "answers": [
            "Yes, they create distinct method signatures",
            "No, they're treated the same at compile-time",
            "Only if combined with different parameter types",
            "Only in async methods"
        ],
        "correctIndices": [1],
        "explanation": "While 'ref' and 'out' are different at runtime, they're considered the same for method overloading at compile-time.",
        "tags": ["c#", "method-overloading", "parameters", "theory"],
        "difficulty": "hard",
        "importance": "rare"
    },
	{
		"type": "multiple_choice",
		"question": "What is a jagged array in C#?",
		"answers": [
			"A single-dimensional array with irregular elements",
			"An array whose elements are arrays of different sizes",
			"A special type of multidimensional array",
			"An array that can only store primitive types"
		],
		"correctIndices": [1],
		"explanation": "A jagged array is an array-of-arrays where each element can hold another array, and these inner arrays can be of different lengths. This differs from rectangular multidimensional arrays which have uniform dimensions. Example: <br><br>int[][] jagged = new int[3][]; <br>jagged[0] = new int[5]; <br>jagged[1] = new int[4]; <br>jagged[2] = new int[2];",
		"tags": ["c#", "arrays", "data-structures", "theory"],
		"difficulty": "medium",
		"importance": "very rare"
	},
	{
		"type": "multiple_choice",
		"question": "What distinguishes a rectangular array from a jagged array in C#?",
		"answers": [
			"Rectangular arrays have uniform dimensions, jagged arrays can vary",
			"Jagged arrays are faster but use more memory",
			"Rectangular arrays can only store reference types",
			"Jagged arrays are limited to 2 dimensions"
		],
		"correctIndices": [0],
		"explanation": "Rectangular arrays (int[,]) have fixed dimensions for all elements (like a grid), while jagged arrays (int[][]) allow each element to reference a different-sized array (like rows of varying lengths).",
		"tags": ["c#", "arrays", "theory"],
		"difficulty": "easy",
		"importance": "very rare"
	},
    {
        "type": "multiple_choice",
        "question": "What is the key difference between String and StringBuilder in C#?",
        "answers": [
            "String is mutable while StringBuilder is immutable",
            "StringBuilder is thread-safe by default",
            "String is immutable while StringBuilder is mutable",
            "StringBuilder can only handle ASCII characters"
        ],
        "correctIndices": [2],
        "explanation": "In C#, String objects are immutable (cannot be changed after creation), so each modification creates a new object. StringBuilder is mutable and designed for efficient string manipulation without creating multiple objects.",
        "tags": ["c#", "strings", "performance"],
        "difficulty": "medium",
        "importance": "important"
    },
    {
        "type": "multiple_choice",
        "question": "What are anonymous types in C#?",
        "answers": [
            "Types without names that inherit from System.Object",
            "Types declared with the 'anonymous' keyword",
            "Types that can only be used in LINQ queries",
            "Types that don't appear in the assembly metadata"
        ],
        "correctIndices": [0],
        "explanation": "Anonymous types are compiler-generated types with read-only properties, typically created using the 'var' keyword with object initializer syntax (e.g., var person = new { Name = \"John\", Age = 30 }).",
        "tags": ["c#", "types", "theory"],
        "difficulty": "easy",
        "importance": "important"
    },
    {
        "type": "multiple_choice",
        "question": "What is the purpose of sealed classes in C#?",
        "answers": [
            "To prevent garbage collection",
            "To make the class thread-safe",
            "To prevent inheritance from the class",
            "To optimize JIT compilation"
        ],
        "correctIndices": [3],
        "explanation": "Sealed classes cannot be inherited from. This is often used for security reasons or to prevent unintended modifications through inheritance. The 'sealed' modifier is also used to prevent overriding of individual methods.",
        "tags": ["c#", "oop", "inheritance"],
        "difficulty": "easy",
        "importance": "standard"
    },
    {
        "type": "multiple_choice",
        "question": "What are partial classes in C# primarily used for?",
        "answers": [
            "Splitting class implementation across multiple files",
            "Creating lightweight class versions",
            "Implementing multiple inheritance",
            "Reducing memory footprint"
        ],
        "correctIndices": [0],
        "explanation": "Partial classes allow splitting a class definition across multiple files, which is especially useful for separating auto-generated code from manual code (like in WinForms or WPF) or organizing large classes.",
        "tags": ["c#", "classes", "code-organization"],
        "difficulty": "easy",
        "importance": "very rare"
    },
    {
        "type": "multiple_choice",
        "question": "Which of these statements is <b>WRONG</b> about partial methods in C#?",
        "answers": [
            "They must return void",
            "They can have out parameters",
            "They are implicitly private",
            "They must begin with partial modifier"
        ],
        "correctIndices": [1],
        "explanation": "Partial methods cannot have out parameters (though they can have ref parameters). Other characteristics: must return void, are private by default, and must be declared with the partial modifier.",
        "tags": ["c#", "methods", "partial-classes"],
        "difficulty": "hard",
        "importance": "rare"
    },
    {
        "type": "multiple_choice",
        "question": "A partial class can span across different namespaces in C#.",
        "answers": ["Yes", "No"],
		"allowAnswerShuffling": false,
        "correctIndices": [1],
        "explanation": "All parts of a partial class must be in the same namespace and assembly. The compiler combines all partial definitions into a single class during compilation.",
        "tags": ["c#", "partial-classes", "namespaces"],
        "difficulty": "easy",
        "importance": "very rare"
    },
    {
        "type": "multiple_choice",
        "question": "What best describes delegates in C#?",
        "answers": [
            "Special classes that can hold multiple method references",
            "Value types that store function pointers",
            "Interfaces for callback operations",
            "Compiler-generated anonymous types"
        ],
        "correctIndices": [0],
        "explanation": "Delegates are type-safe function pointers that can hold references to methods. Multicast delegates can hold multiple methods (+= adds, -= removes).<br><br>Example:<br>delegate void MyDelegate(string msg);<br>MyDelegate del = ShowMessage;<br>del += LogMessage; // Multicast",
        "tags": ["c#", "delegates", "events"],
        "difficulty": "medium",
        "importance": "standard"
    },
	{
		"type": "multi_select",
		"question": "What are the key differences between the 'as' and 'is' operators in C#?",
		"answers": [
				"'as' performs casting while 'is' only checks type compatibility",
				"'as' returns null on failure while 'is' returns false",
				"Both operators work exactly the same way",
				"'as' can throw InvalidCastException for value types while 'is' never throws",
				"'is' can be used with unboxing while 'as' cannot"
		],
		"correctIndices": [0, 1, 3],
		"explanation": "<strong>Key differences between 'as' and 'is':</strong><br><br>1. Purpose:<br>&nbsp;&nbsp;- 'is' checks type compatibility (returns bool)<br>&nbsp;&nbsp;- 'as' performs actual casting (returns object or null)<br><br>2. Failure behavior:<br>&nbsp;&nbsp;- 'is' returns false on failure (never throws)<br>&nbsp;&nbsp;- 'as' returns null for reference types, throws for value types<br><br>3. Usage:<br>&nbsp;&nbsp;- 'is' is often used with if-statements for type checking<br>&nbsp;&nbsp;- 'as' is used when you want to attempt a cast and handle null<br><br><em>Note: For value types, use 'is' with pattern matching: <code>if(obj is int i) { }</code></em>",
		"tags": ["c#", "operators", "type-conversion"],
		"difficulty": "medium",
		"importance": "important"
	},
    {
        "type": "multiple_choice",
        "question": "What distinguishes .Equals() from == in C#?",
        "answers": [
            "== compares references for objects, .Equals() compares values",
            ".Equals() is only for primitives, == works with all types",
            "They behave identically in all cases",
            "== is case-sensitive, .Equals() isn't"
        ],
        "correctIndices": [0],
        "explanation": "For reference types, == compares memory addresses by default while .Equals() compares content (can be overridden). For value types, both compare values.<br><br>Example:<br>string a = \"test\";<br>string b = \"test\";<br>a == b // true (special string behavior)<br>object.ReferenceEquals(a,b) // false",
        "tags": ["c#", "operators", "comparison"],
        "difficulty": "medium",
        "importance": "important"
    },
    {
        "type": "multiple_choice",
        "question": "What is constructor chaining in C#?",
        "answers": [
            "Calling one constructor from another using this()",
            "Linking constructors across different classes",
            "A design pattern for factory classes",
            "Creating constructor delegates"
        ],
        "correctIndices": [0],
        "explanation": "Constructor chaining avoids code duplication by having constructors call each other.<br><br>Example:<br>public class Person {<br>    public Person() : this(\"Unknown\") {}<br>    public Person(string name) { /*...*/ }<br>}",
        "tags": ["c#", "constructor", "oop"],
        "difficulty": "medium",
        "importance": "standard"
    },
    {
        "type": "multiple_choice",
        "question": "Which constructor type does NOT exist in C#?",
        "answers": [
            "Copy constructor",
            "Destructor constructor", 
            "Static constructor",
            "Private constructor"
        ],
        "correctIndices": [1],
        "explanation": "C# has:<br>- Default (parameterless)<br>- Parameterized<br>- Static (class initializer)<br>- Private (singleton pattern)<br>- Copy (clone via constructor)<br><br>Destructors (~Class) exist but aren't constructors.",
        "tags": ["c#", "constructor", "theory"],
        "difficulty": "hard",
        "importance": "standard"
    },
	{
		"type": "multiple_choice",
		"question": "What are <b>.gitattributes</b> files primarily used for in Git?",
		"answers": [
			"To define repository access permissions",
			"To specify how Git should handle specific files (line endings, diff behavior, etc.)",
			"To configure user-specific Git settings",
			"To list all files that should be included in commits"
		],
		"correctIndices": [1],
		"explanation": ".gitattributes files are used to set attributes for paths in your repository. This lets you control behaviors like:<br><br>- Line ending normalization (CRLF vs LF)<br>- Which files should be treated as binary<br>- Custom diff/merge behavior for specific file types<br>- Filter and clean operations<br><br>Example:<br><br>*.js    text eol=lf<br>*.bat    text eol=crlf<br>*.png    binary",
		"tags": ["git", "version-control", "gitattributes"],
		"difficulty": "easy",
		"importance": "important"
	},
	{
		"type": "multiple_choice",
		"question": "What is the key architectural difference between monoliths and microservices?",
		"answers": [
			"Monoliths use fewer programming languages",
			"Microservices bundle all functionality in one deployable unit",
			"Monoliths combine all components into a single codebase, while microservices separate them into independent services",
			"Microservices can only be deployed on cloud platforms"
		],
		"correctIndices": [2],
		"explanation": "The fundamental difference is architectural organization:<br><br>- **Monolith**: All components (UI, business logic, database access) are tightly coupled in one codebase<br>- **Microservices**: Functionality is split into independent services communicating via APIs<br><br>Key implications:<br><br>• Monoliths are simpler to deploy but harder to scale<br>• Microservices enable independent scaling but add complexity<br>• Microservices require service discovery and API gateways",
		"tags": ["architecture", "microservices"],
		"difficulty": "easy",
		"importance": "important"
	},
	{
		"type": "multiple_choice",
		"question": "What is upcasting in C#?",
		"answers": [
			"Converting a subclass instance to a superclass type",
			"Converting a superclass instance to a subclass type",
			"Changing an object's type at runtime",
			"Optimizing memory usage by reducing type hierarchy"
		],
		"correctIndices": [0],
		"explanation": "Upcasting is safe and implicit:<br><br>• Moves up the inheritance hierarchy<br>• Example: <code>Animal a = new Dog();</code><br>• No runtime cost as it's a compile-time operation",
		"tags": ["c#", "oop", "casting"],
		"difficulty": "easy",
		"importance": "important"
	},
	{
		"type": "multiple_choice",
		"question": "Why is downcasting potentially dangerous?",
		"answers": [
			"It always causes memory leaks",
			"It requires runtime type checking and may throw InvalidCastException",
			"It breaks encapsulation",
			"It forces garbage collection"
		],
		"correctIndices": [1],
		"explanation": "Downcasting risks:<br><br>• Requires explicit cast: <code>Dog d = (Dog)animal;</code><br>• Needs runtime type check (performance cost)<br>• Throws <code>InvalidCastException</code> if types are incompatible<br>• Safer alternatives: <code>as</code> operator or pattern matching",
		"tags": ["c#", "oop", "casting", "performance"],
		"difficulty": "medium",
		"importance": "important"
	},
	{
		"type": "multiple_choice",
		"question": "What is the performance cost of frequent downcasting?",
		"answers": [
			"No cost - it's optimized at compile time",
			"Minimal stack allocation overhead",
			"Runtime type checks and potential virtual method table lookups",
			"Forces JIT recompilation"
		],
		"correctIndices": [2],
		"explanation": "Downcasting costs include:<br><br>• Runtime type verification (isinst instruction in CIL)<br>• Virtual method dispatch overhead<br>• Cache pollution from type checks<br><br>Performance tip: Prefer polymorphism over explicit casting",
		"tags": ["c#", "oop", "casting", "performance", "theory"],
		"difficulty": "hard",
		"importance": "standard"
	},
	{
		"type": "multiple_choice",
		"question": "What is the performance cost of frequent upcasting?",
		"answers": [
			"No cost - it's optimized at compile time",
			"Minimal stack allocation overhead",
			"Runtime type checks and potential virtual method table lookups",
			"Forces JIT recompilation"
		],
		"correctIndices": [0],
		"explanation": "Downcasting costs include:<br><br>• Runtime type verification (isinst instruction in CIL)<br>• Virtual method dispatch overhead<br>• Cache pollution from type checks<br><br>Performance tip: Prefer polymorphism over explicit casting",
		"tags": ["c#", "oop", "casting", "performance", "theory"],
		"difficulty": "hard",
		"importance": "standard"
	},
	{
		"type": "multiple_choice",
		"question": "Which of the following best demonstrates runtime polymorphism in C#?",
		"answers": [
			"Method overloading",
			"Using the 'var' keyword",
			"Method overriding with virtual/override keywords",
			"Using extension methods"
		],
		"correctIndices": [2],
		"explanation": "Runtime polymorphism (dynamic polymorphism) in C# is achieved through method overriding using the <b>virtual</b> and <b>override</b> keywords.<br><br>Method overloading is compile-time polymorphism, 'var' is just type inference, and extension methods are static.",
		"tags": ["c#", "oop", "polymorphism", "theory"],
		"difficulty": "medium",
		"importance": "rare"
	},
	{
		"type": "multi_select",
		"question": "Which concepts in C# relate to polymorphism?",
		"answers": [
			"Abstract classes",
			"Interface implementation",
			"Sealed classes",
			"Virtual methods",
			"Static methods"
		],
		"correctIndices": [0, 1, 3],
		"explanation": "Polymorphism in C# is achieved through:<br>- Abstract classes (can be inherited with different implementations)<br>- Interfaces (multiple implementations possible)<br>- Virtual methods (allow overriding)<br><br>Sealed classes prevent polymorphism, and static methods are bound at compile-time.",
		"tags": ["c#", "oop", "polymorphism", "theory"],
		"difficulty": "hard",
		"importance": "rare"
	},
	{
		"type": "info",
		"question": "What is polymorphism (in the context of programming)",
		"explanation": "Polymorphism is the ability (in programming) to present the same interface for differing underlying forms (data types).",
		"tags": ["c#", "oop", "polymorphism", "theory"],
		"difficulty": "medium",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is the primary purpose of HTTP 1XX status codes?",
		"answers": [
			"To indicate that the server encountered an error",
			"To provide informational responses during request processing",
			"To confirm successful request completion",
			"To force the client to redirect"
		],
		"correctIndices": [1],
		"explanation": "1XX codes (e.g., 100 Continue) are <b>informational</b> and rarely used in modern web apps. They indicate interim responses while the request is still being processed.",
		"tags": ["http", "status-code"],
		"difficulty": "easy",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "In ASP.NET Core, what status code is automatically returned when a controller action returns a serializable object without explicitly setting a status code?",
		"answers": [
			"201 Created",
			"204 No Content",
			"200 OK",
			"202 Accepted"
		],
		"correctIndices": [2],
		"explanation": "ASP.NET defaults to <b>200 OK</b> for successful responses with a body. 201/204 require explicit returns (e.g., <code>Created()</code> or <code>NoContent()</code>).",
		"tags": ["asp.net", "http", "status-code"],
		"difficulty": "easy",
		"importance": "rare"
	},
	{
		"type": "multi_select",
		"question": "Which of these are common uses for HTTP 3XX status codes?",
		"answers": [
			"Temporary URL redirection (e.g., 302 Found)",
			"Permanent URL changes (e.g., 301 Moved Permanently)",
			"Client authentication errors",
			"Cache invalidation directives"
		],
		"correctIndices": [0, 1],
		"explanation": "3XX codes handle <b>redirects</b>:<br>- 301: Permanent move<br>- 302/307: Temporary redirect<br>- 304: Not Modified (caching). Client errors (4XX) and caching are separate concerns.",
		"tags": ["http", "status-code"],
		"difficulty": "medium",
		"importance": "rare"
	},
	{
		"type": "text_input",
		"question": "What HTTP status code should be returned when a client requests a resource that doesn't exist?",
		"correctAnswers": ["404", "404 Not Found"],
		"explanation": "<b>404 Not Found</b> is the standard response for non-existent resources. Other 4XX codes (e.g., 400 Bad Request, 403 Forbidden) address different client-side issues.",
		"tags": ["http", "status-code"],
		"difficulty": "easy",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "When should a 5XX status code be returned in a web API?",
		"answers": [
			"When the client sends malformed JSON",
			"When the server crashes while processing a valid request",
			"When authentication credentials are missing",
			"When a query parameter is invalid"
		],
		"correctIndices": [1],
		"explanation": "5XX codes indicate <b>server-side failures</b> (e.g., 500 Internal Server Error). Malformed requests/auth issues (4XX) are the client's responsibility.",
		"tags": ["http", "status-code"],
		"difficulty": "medium",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "When should you use PUT instead of POST in a REST API?",
		"answers": [
			"When creating a new resource with server-generated ID",
			"When updating an existing resource completely (idempotent operation)",
			"When performing partial updates to a resource",
			"When retrieving resource data"
		],
		"correctIndices": [1],
		"explanation": "<b>PUT</b> is for <i>complete updates</i> of known resources (idempotent).<br><b>POST</b> creates new resources (non-idempotent) or when the URI isn't known.<br>Partial updates often use PATCH.",
		"tags": ["http", "rest", "api"],
		"difficulty": "medium",
		"importance": "standard"
	},
	{
		"type": "multi_select",
		"question": "Which statements about PUT and POST are true?",
		"answers": [
			"PUT requests must be idempotent",
			"POST is suitable for creating subordinate resources <i>(I.e. /posts is the parent resource then /posts/{postId}/comments are subordinate resources)</i>",
			"PUT should be used when the client generates the resource ID",
			"POST is inherently idempotent"
		],
		"correctIndices": [0, 1],
		"explanation": "Key differences:<br>- <b>PUT</b>: Idempotent (same request → same state), full updates<br>- <b>POST</b>: Non-idempotent (creates new state), flexible usage<br>Client-generated IDs can use PUT if the URI is known.",
		"tags": ["http", "rest", "api"],
		"difficulty": "hard",
		"importance": "standard"
	},
	{
		"type": "text_input",
		"question": "What HTTP method should be used when adding a new comment to a blog post where the server assigns the comment ID?",
		"correctAnswers": ["Post", "[Post]"],
		"explanation": "Use <b>POST</b> when:<br>- The server controls the resource ID (/posts/123/comments)<br>- The operation isn't idempotent (multiple requests create multiple comments)",
		"tags": ["http", "rest", "api"],
		"difficulty": "medium",
		"importance": "standard"
	},
	{
		"type": "multiple_choice",
		"question": "Why is PUT considered idempotent while POST is not?",
		"answers": [
			"PUT includes authentication headers",
			"Repeating a PUT request leaves the resource in the same state as a single request",
			"POST supports JSON payloads",
			"PUT requests are slower"
		],
		"correctIndices": [1],
		"explanation": "<b>Idempotency</b> means identical requests produce identical server state.<br>PUT achieves this by fully replacing resources at known URIs, while POST creates new state with each request.",
		"tags": ["http", "rest", "api", "theory"],
		"difficulty": "hard",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "What does it mean for an HTTP method to be idempotent?",
		"answers": [
		"The request will always return the same response",
		"Making the same request once or multiple times produces the same server-side state",
		"The request can only be executed once successfully",
		"The request payload must contain an ID field"
		],
		"correctIndices": [1],
		"explanation": "In REST APIs, <b>idempotency</b> means that making the same request one or multiple times leaves the server in the <i>identical state</i>.<br><br>Examples:<br>- <b>PUT</b>: Idempotent (repeated updates yield same result)<br>- <b>DELETE</b>: Idempotent (deleting an already deleted resource)<br>- <b>POST</b>: Not idempotent (each request creates new resources)",
		"tags": ["http", "rest", "api", "theory"],
		"difficulty": "medium",
		"importance": "important"
	},
	{
		"type": "text_input",
		"question": "In ASP.NET Core, which HTTP method attribute ([HttpPost], etc.) should be used for an idempotent operation that updates an existing product by ID?",
		"correctAnswers": ["HttpPut", "[HttpPut]", "Put", "[Put]"],
		"explanation": "Use <code>[HttpPut]</code> because:<br>- Updates to known URIs (/products/{id}) should be idempotent<br>- PUT semantics match complete resource replacement<br>- ASP.NET's model binding validates the ID exists",
		"tags": ["c#", "asp.net", "rest", "api"],
		"difficulty": "easy",
		"importance": "standard"
	},
	{
		"type": "multiple_choice",
		"question": "What is the primary purpose of database sharding?",
		"answers": [
		"To reduce the number of tables in a database",
		"To horizontally split a table's rows across multiple partitions for scalability",
		"To encrypt sensitive data in a database",
		"To create backup copies of a database"
		],
		"correctIndices": [1],
		"explanation": "Sharding <b>horizontally partitions</b> a table's rows into smaller, more manageable tables (often across different servers). This improves <b>scalability</b> by distributing load, unlike vertical partitioning (column splits) or backups.",
		"tags": ["database"],
		"difficulty": "easy",
		"importance": "important"
	},
	{
		"type": "multi_select",
		"question": "Which of these are common challenges when implementing database sharding?",
		"answers": [
		"Increased join complexity across shards",
		"Difficulty in maintaining ACID transactions spanning multiple shards",
		"Reduced write throughput due to partitioning",
		"Balancing uneven data distribution (hotspots)"
		],
		"correctIndices": [0, 1, 3],
		"explanation": "Sharding introduces:<br>- <b>Cross-shard joins</b> (slow/no native support)<br>- <b>Distributed transaction</b> challenges (e.g., 2PC needed)<br>- <b>Hotspots</b> (poor shard-key choice skews load)<br>Write throughput typically <i>improves</i> due to parallelization.",
		"tags": ["database"],
		"difficulty": "hard",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "When should you add a database index to a column?",
		"answers": [
		"When the column is rarely used in queries",
		"When the column is frequently filtered, sorted, or joined on",
		"When the column stores large binary data (e.g., images)",
		"When the column has low cardinality (e.g., boolean fields)"
		],
		"correctIndices": [1],
		"explanation": "Indexes improve read performance for columns often used in <b>WHERE</b>, <b>JOIN</b>, or <b>ORDER BY</b> clauses. Avoid indexing:<br>- Low-cardinality fields (e.g., gender)<br>- Columns with frequent write operations (indexes slow inserts/updates)<br>- Large BLOB/TEXT data.",
		"tags": ["database", "performance"],
		"difficulty": "easy",
		"importance": "important"
	},
	{
		"type": "multi_select",
		"question": "In which scenarios would a table need multiple primary keys (composite key)?",
		"answers": [
		"To enforce uniqueness across a combination of columns (e.g., student_id + course_id)",
		"When modeling a many-to-many relationship (a.k.a. junction table, a.k.a. cross table)",
		"To improve query performance on a single column",
		"When all columns individually require auto-incrementing values"
		],
		"correctIndices": [0, 1],
		"explanation": "Composite primary keys are useful for:<br>- <b>Junction tables</b> (e.g., <code>student_courses</code> with student_id + course_id)<br>- <b>Natural keys</b> where multiple columns guarantee uniqueness (e.g., order_id + product_id)<br>Single-column performance is better addressed with indexes.",
		"tags": ["database"],
		"difficulty": "medium",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is the purpose of the 'fillfactor' setting in a database?",
		"answers": [
		"To determine the percentage of a disk drive allocated to a database",
		"To control how much free space is reserved in database pages for future updates",
		"To specify the compression ratio for large binary data",
		"To limit the number of rows stored in a table"
		],
		"correctIndices": [1],
		"explanation": "The <b>fillfactor</b> (e.g., <code>FILLFACTOR=80</code>) defines the percentage of space <i>initially filled</i> in database pages (e.g., B-tree leaves), leaving the rest free for future updates.<br><br><u>Example</u>: A fillfactor of 70% means 30% of each page remains empty to accommodate row expansions (e.g., VARCHAR updates) without requiring page splits.",
		"tags": ["database", "performance"],
		"difficulty": "hard",
		"importance": "very rare"
	},
	{
		"type": "multiple_choice",
		"question": "Which of the following describes a pure function?",
		"answers": [
			"A function that can modify external state",
			"A function that always returns the same output for the same input and has no side effects",
			"A function that must be written in a functional programming language",
			"A function that performs I/O operations"
		],
		"correctIndices": [1],
		"explanation": "A pure function has two key characteristics:<br>1) It always returns the same output for the same input (deterministic).<br>2) It has no side effects (doesn't modify external state or variables).",
		"tags": ["functional programming", "theory"],
		"difficulty": "easy",
		"importance": "very rare"
	},
	{
		"type": "multiple_choice",
		"question": "In SQL, what are 'JOINS' primarily used for?",
		"answers": [
		"To combine rows from two or more tables based on related columns",
		"To merge multiple databases into a single database",
		"To convert table data into JSON format",
		"To create backup copies of tables before modification"
		],
		"correctIndices": [0],
		"explanation": "SQL <b>JOINS</b> combine data from multiple tables by matching values in specified columns (usually primary/foreign keys).<br><br>Common JOIN types:<br>- <b>INNER JOIN</b>: Returns matching rows only<br>- <b>LEFT/RIGHT JOIN</b>: Returns all rows from one table + matches from the other<br>- <b>FULL JOIN</b>: Returns all rows when there's a match in either table",
		"tags": ["sql", "database", "query", "theory"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "multi_select",
		"question": "Which of these statements about SQL JOINs are true?",
		"answers": [
		"A LEFT JOIN always returns at least as many rows as the left table",
		"INNER JOINs eliminate non-matching rows from both tables",
		"CROSS JOINs produce a Cartesian product of all rows",
		"JOIN conditions must always use primary/foreign key relationships"
		],
		"correctIndices": [0, 1, 2],
		"explanation": "Key JOIN facts:<br>- <b>LEFT JOIN</b> preserves all left-table rows (right-table cols NULL if no match)<br>- <b>INNER JOIN</b> filters non-matches from both sides<br>- <b>CROSS JOIN</b> combines every row from both tables<br>- JOINs can use any related columns, not just PK/FK pairs.<br><br><img src=\"img/questions/SqlJoins.png\" width=\"100%\">",
		"tags": ["sql", "database", "query", "theory"],
		"difficulty": "hard",
		"importance": "rare"
	},
	{
		"type": "multi_select",
		"question": "Which of the following are benefits of using a primary key in database tables?",
		"answers": [
		"Faster search operations due to automatic indexing",
		"Guaranteed ability to identify unique rows in the table",
		"Precise targeting of records for updates/deletes",
		"Automatic sorting of table data by the primary key",
		"Prevention of duplicate record insertion",
		"Enforcement of referential integrity through foreign keys",
		"Reduction in overall database storage requirements",
		"Automatic encryption of sensitive data in the table",
		"Elimination of the need for any other indexes",
		"Guaranteed improvement in all query performance"
		],
		"correctIndices": [0, 1, 2, 3, 4, 5],
		"explanation": "Primary keys provide these essential benefits:<br><br><b>Performance & Identification:</b><br>- Automatic index creation (faster searches)<br>- Unique row identification<br>- Precise record targeting<br><br><b>Data Integrity:</b><br>- Prevents duplicates<br>- Enables foreign key relationships<br><br><b>Storage Organization:</b><br>- Data is physically sorted by PK (in clustered indexes)<br><br>Note: PKs don't reduce storage needs (they add index structures), don't encrypt data, and while they help many queries, they don't eliminate the need for other indexes or guarantee all queries will be faster.",
		"tags": ["database"],
		"difficulty": "medium",
		"importance": "essential"
	},
	{
		"type": "multi_select",
		"question": "Which of the following statements about database constraints are true?",
		"answers": [
		"NOT NULL constraints prevent NULL values in a column",
		"UNIQUE constraints ensure all values in a column are identical",
		"PRIMARY KEY constraints combine NOT NULL and UNIQUE properties",
		"FOREIGN KEY constraints enforce referential integrity between tables",
		"CHECK constraints validate data against a logical expression",
		"DEFAULT constraints automatically apply when no value is specified",
		"Constraints can only be applied at the column level, not table level",
		"Constraints improve query performance by creating automatic indexes",
		"Constraints are enforced only during INSERT operations, not UPDATEs",
		"A table can have multiple UNIQUE constraints but only one PRIMARY KEY"
		],
		"correctIndices": [0, 2, 3, 4, 5, 9],
		"explanation": "<b>Key facts about constraints:</b><br><br>✓ <b>NOT NULL</b>: Blocks NULL values in a column<br>✓ <b>PRIMARY KEY</b>: Uniquely identifies rows (NOT NULL + UNIQUE)<br>✓ <b>FOREIGN KEY</b>: Maintains relationships between tables<br>✓ <b>CHECK</b>: Validates data (e.g., salary > 0)<br>✓ <b>DEFAULT</b>: Provides fallback values<br><br><b>Common misconceptions:</b><br>✗ UNIQUE requires distinct values (not identical)<br>✗ Constraints work at both column and table levels<br>✗ Only PRIMARY KEY/UNIQUE create indexes automatically<br>✗ Constraints apply to both INSERT and UPDATE operations",
		"tags": ["database", "sql"],
		"difficulty": "hard",
		"importance": "standard"
	},
	{
		"type": "multi_select",
		"question": "Which of the following are ACTUAL sorting algorithms used in computer science?",
		"answers": [
		"Bubble Sort",
		"Quantum Bogo Sort",
		"Merge Sort",
		"Spaghetti Sort",
		"Quick Sort",
		"Sleep Sort",
		"Radix Sort",
		"Blockchain Sort",
		"Insertion Sort",
		"AI Neural Sort",
		"Heap Sort",
		"Selection Sort",
		"Pancake Sort",
		"Tim Sort",
		"Cloud Merge Sort",
		"Bucket Sort",
		"Counting Sort",
		"Taco Sort"
		],
		"correctIndices": [0, 2, 4, 6, 7, 8, 10, 11, 12, 13, 15, 16],
		"explanation": "<b>Real sorting algorithms:</b><br>• <b>O(n²)</b>: Bubble, Insertion, Selection<br>• <b>O(n log n)</b>: Merge, Quick, Heap, Tim<br>• <b>Specialized</b>: Radix, Bucket, Counting<br>• <b>Unconventional but real</b>: Pancake, Sleep (though not practical)<br><br><b>Fake algorithms:</b><br>• Quantum Bogo Sort (parody of Bogo Sort)<br>• Spaghetti Sort (physical demo, not real algorithm)<br>• AI Neural Sort/Cloud Merge Sort/Taco Sort (made-up)<br><br><b>Note:</b> 'Blockchain Sort' is fictional, though Radix is sometimes confused with it",
		"tags": ["algorithms", "sorting", "math"],
		"difficulty": "hard",
		"importance": "essential"
	},
	{
		"type": "multiple_choice",
		"question": "What is the primary purpose of the Singleton pattern?",
		"answers": [
		"To create multiple instances of a class with different configurations",
		"To ensure a class has only one instance and provide global access to it",
		"To dynamically add responsibilities to an object",
		"To convert one interface into another"
		],
		"correctIndices": [1],
		"explanation": "The <b>Singleton</b> pattern ensures a class has only one instance and provides a global point of access to it. Common uses include logging, driver objects, and caching.",
		"tags": ["design-pattern"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "multiple_choice",
		"question": "When is the Builder pattern most useful?",
		"answers": [
		"When you need to ensure only one instance exists",
		"When constructing complex objects with many optional parameters",
		"When you want to share common properties between objects",
		"When adapting an interface to another"
		],
		"correctIndices": [1],
		"explanation": "The <b>Builder</b> pattern separates object construction from its representation, ideal for objects requiring multiple steps or configurations (e.g., HTML generators, complex DTOs).",
		"tags": ["design-pattern"],
		"difficulty": "medium",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is the difference between a class and an object in Object-Oriented Programming (OOP)?",
		"answers": [
			"A class is a runtime instance, while an object is a compile-time template",
			"A class is a blueprint, while an object is an instance of that class",
			"A class defines behavior only, while an object defines data only",
			"A class and an object are the same thing in OOP"
		],
		"correctIndices": [1],
		"explanation": "A <b>class</b> is a blueprint or template (e.g., 'some yellow creature'), while an <b>object</b> is a concrete instance of that class (e.g., 'Yellow Pikachu, age 18 and lightning fast'). Classes define structure (attributes/methods), while objects hold actual data.",
		"tags": ["theory", "oop"],
		"difficulty": "easy",
		"importance": "important"
	},
	{
		"type": "multiple_choice",
		"question": "What does the Prototype pattern primarily involve?",
		"answers": [
		"Creating new objects by copying an existing prototype",
		"Defining an interface for creating families of related objects",
		"Wrapping an object to provide new behavior",
		"Decoupling abstraction from implementation"
		],
		"correctIndices": [0],
		"explanation": "The <b>Prototype</b> pattern creates new objects by cloning a prototype instance, avoiding expensive creation logic. Used when object creation is more costly than copying.",
		"tags": ["design-pattern"],
		"difficulty": "medium",
		"importance": "very rare"
	},
	{
		"type": "multiple_choice",
		"question": "Which problem does the Adapter pattern solve?",
		"answers": [
		"Incompatible interfaces/code between classes or systems",
		"Expensive object creation",
		"Complex object construction",
		"Managing hierarchical object structures"
		],
		"correctIndices": [0],
		"explanation": "The <b>Adapter</b> pattern acts as a bridge between two incompatible interfaces (e.g., converting XML data to JSON format for an existing system).",
		"tags": ["design-pattern"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "multiple_choice",
		"question": "What is the key benefit of the Bridge pattern?",
		"answers": [
		"It combines multiple small objects into a tree structure",
		"It decouples an abstraction from its implementation",
		"It restricts object creation to a single instance",
		"It adds responsibilities to objects dynamically"
		],
		"correctIndices": [1],
		"explanation": "The <b>Bridge</b> pattern separates abstraction (interface) from implementation (platform-specific details), allowing them to vary independently (i.e. multiple UI themes that can be applied to the same code. Basically blackbox or common sense or good code.",
		"tags": ["design-pattern"],
		"difficulty": "medium",
		"importance": "standard"
	},
	{
		"type": "multiple_choice",
		"question": "The Composite pattern is best suited for:",
		"answers": [
		"Treating individual objects and compositions uniformly",
		"Optimizing memory usage for many similar objects",
		"Creating objects without specifying their concrete classes",
		"Providing a simplified interface to a complex subsystem"
		],
		"correctIndices": [0],
		"explanation": "The <b>Composite</b> pattern lets clients treat individual objects and compositions uniformly (e.g., file/folder systems, GUI components).",
		"tags": ["design-pattern"],
		"difficulty": "medium",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "How does the Decorator pattern work?",
		"answers": [
		"By subclassing for added functionality",
		"By wrapping objects to add new behaviors dynamically",
		"By sharing state between similar objects",
		"By converting interfaces to match client expectations"
		],
		"correctIndices": [1],
		"explanation": "The <b>Decorator</b> pattern attaches additional responsibilities to objects dynamically (e.g., adding encryption to file I/O streams without subclassing).",
		"tags": ["design-pattern"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "multiple_choice",
		"question": "What does the Facade pattern provide?",
		"answers": [
		"A simplified interface to a complex subsystem",
		"A way to create object families without specifying classes",
		"Fine-grained control over object creation",
		"Dynamic addition of object responsibilities"
		],
		"correctIndices": [0],
		"explanation": "The <b>Facade</b> pattern offers a unified interface to a set of interfaces in a subsystem (e.g., a single 'Compiler' class hiding lexer/parser/optimizer complexity).",
		"tags": ["design-pattern"],
		"difficulty": "medium",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "When should you use the Flyweight pattern?",
		"answers": [
		"To manage state shared across many similar objects",
		"To ensure only one instance of a class exists",
		"To build complex objects step-by-step",
		"To combine objects into tree structures"
		],
		"correctIndices": [0],
		"explanation": "The <b>Flyweight</b> pattern minimizes memory usage by sharing intrinsic state between similar objects (e.g., character formatting in word processors, particle systems in games).",
		"tags": ["design-pattern"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "multiple_choice",
		"question": "Which is NOT a use case for the Proxy pattern?",
		"answers": [
		"Controlling access to sensitive objects",
		"Delaying expensive object creation until needed",
		"Providing a local placeholder for remote objects",
		"Defining families of related objects"
		],
		"correctIndices": [3],
		"explanation": "The <b>Proxy</b> pattern provides a surrogate/placeholder for another object (for access control, lazy initialization, or remote interaction). Defining object families is handled by the Abstract Factory pattern.",
		"tags": ["design-pattern"],
		"difficulty": "hard",
		"importance": "rare"
	},
	{
		"type": "text_input",
		"question": "What does each letter in the SOLID acronym stand for in object-oriented design?",
		"correctAnswers": [
		"Single Responsibility Principle, Open/Closed Principle, Liskov Substitution Principle, Interface Segregation Principle, Dependency Inversion Principle",
		"Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion"
		],
		"explanation": "SOLID principles are:<br><b>S</b>: A class should have one reason to change<br><b>O</b>: Open for extension, closed for modification<br><b>L</b>: Subclasses should be substitutable for their base classes<br><b>I</b>: Many client-specific interfaces are better than one general-purpose interface<br><b>D</b>: Depend on abstractions, not concretions",
		"tags": ["design-principle"],
		"difficulty": "medium",
		"importance": "essential"
	},
	{
		"type": "multiple_choice",
		"question": "What does the Open-Closed Principle (OCP) state about software entities?",
		"answers": [
		"They should allow modification of existing code for new features",
		"They should be open for extension but closed for modification",
		"They must be rewritten whenever requirements change",
		"They should expose all internal methods for flexibility"
		],
		"correctIndices": [1],
		"explanation": "The <b>Open-Closed Principle</b> (the 'O' in SOLID) means:<br>- <b>Open for extension</b>: New behavior can be added via new code (inheritance, composition)<br>- <b>Closed for modification</b>: Existing working code shouldn't be changed<br><br>Example: Adding new payment methods via <code>IPaymentProcessor</code> rather than modifying an existing processor class.<br><br>Note that this is almost never correctly or applied at all in the real world.",
		"tags": ["design-principle"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "multi_select",
		"question": "Which techniques help adhere to the Open-Closed Principle?",
		"answers": [
		"Using inheritance with method overriding",
		"Modifying class internals whenever adding features",
		"Implementing plugin architectures",
		"Making all methods virtual by default"
		],
		"correctIndices": [0, 2],
		"explanation": "<br>OCP-compliant approaches:<br>- <b>Inheritance</b>: Extend base class functionality<br>- <b>Composition</b>: Strategy pattern, dependency injection<br>- <b>Plugins</b>: Load new modules dynamically<br><br>Anti-patterns:<br>- Modifying stable code (breaks 'closed' rule)<br>- Overusing virtual methods (not a goal in itself)",
		"tags": ["solid", "design-pattern"],
		"difficulty": "medium",
		"importance": "rare"
	},
	{
		"type": "text_input",
		"question": "What does KISS stand for in software development?",
		"correctAnswers": [
		"Keep It Simple Stupid",
		"Keep It Short and Simple",
		"Keep It Simple Software"
		],
		"explanation": "The <b>KISS principle</b> advocates simplicity in design. Complex systems are harder to maintain, debug, and scale.",
		"tags": ["design-principle"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "text_input",
		"question": "What does DRY stand for in programming?",
		"correctAnswers": [
		"Don't Repeat Yourself",
		"Do Not Repeat Yourself"
		],
		"explanation": "The <b>DRY principle</b> aims to reduce repetition by abstracting shared logic into a single source of truth.",
		"tags": ["design-principle"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "text_input",
		"question": "What does YAGNI stand for in Agile development?",
		"correctAnswers": [
		"You Aren't Gonna Need It"
		],
		"explanation": "<b>YAGNI</b> warns against adding functionality until it's actually needed, to avoid over-engineering.",
		"tags": ["design-principle"],
		"difficulty": "medium",
		"importance": "rare"
	},
	{
		"type": "text_input",
		"question": "What does ACID stand for in database transactions?",
		"correctAnswers": [
		"Atomicity, Consistency, Isolation, Durability"
		],
		"explanation": "<b>ACID</b> guarantees:<br>- <b>Atomicity</b>: All-or-nothing transactions<br>- <b>Consistency</b>: Valid state transitions<br>- <b>Isolation</b>: Concurrent transactions don't interfere<br>- <b>Durability</b>: Committed transactions survive crashes",
		"tags": ["database", "design-principle"],
		"difficulty": "medium",
		"importance": "essential"
	},
	{
		"type": "text_input",
		"question": "What does SRP stand for in programming?",
		"correctAnswers": ["Single Responsibility Principle", "Single Responsibility"],
		"explanation": "A class should have only one reason to change, meaning it should have only one responsibility or job.",
		"tags": ["database", "design-principle"],
		"difficulty": "easy",
		"importance": "standard"
	},	
	{
		"type": "text_input",
		"question": "What does NIH stand for in software development culture?",
		"correctAnswers": [
		"Not Invented Here"
		],
		"explanation": "The <b>NIH syndrome</b> describes a team's reluctance to use third-party solutions, preferring to build everything in-house even when existing options are better. This often leads to wasted effort and maintenance overhead.<br><br>Antidotes include:<br>- Evaluating existing libraries/frameworks first<br>- Open-source adoption<br>- Inner-source practices",
		"tags": ["anti-patterns"],
		"difficulty": "easy",
		"importance": "very rare"
	},
	{
		"type": "multi_select",
		"question": "Which of the following statements about test doubles are correct? (Select all that apply)",
		"answers": [
		"Stubs provide indirect input to the code under test",
		"Mocks simulate real objects and define expectations about their interactions",
		"Spies record information about how they were called in addition to stubbing behavior",
		"Fakes are fully functional implementations used in production",
		"Dummies contain real business logic but are only used in tests",
		"Mocks verify both method calls and their return values",
		"Fakes often use simplified implementations (e.g., in-memory database)",
		"Dummies are just placeholder objects that fill parameter lists"
		],
		"correctIndices": [0, 1, 2, 5, 6, 7],
		"explanation": "Key characteristics of test doubles:<br><br>✅ <b>Stubs</b>: Provide canned responses (indirect input)<br>✅ <b>Mocks</b>: Simulate objects + verify interactions (expectations)<br>✅ <b>Spies</b>: Record call information (e.g., call counts)<br>✅ <b>Fakes</b>: Working but simplified implementations (test-only)<br>✅ <b>Dummies</b>: Empty objects filling parameter requirements<br><br>❌ <i>Fakes are not production-ready</i> (they sacrifice functionality for test speed)<br>❌ <i>Dummies contain no logic</i> (they're just placeholders)",
		"tags": ["testing"],
		"difficulty": "hard",
		"importance": "important"
	},
	{
		"type": "multiple_choice",
		"question": "What is the primary purpose of smoke testing in software development?",
		"answers": [
		"To perform exhaustive testing of all system features",
		"To verify that the most critical functions of a build work before deeper testing",
		"To measure code coverage percentage",
		"To validate user interface aesthetics"
		],
		"correctIndices": [1],
		"explanation": "<b>Smoke testing</b> (also called \"build verification testing\") is a shallow but wide test of core functionality to determine if a build is stable enough for further testing. It answers: <i>\"Does the software start without catching fire?\"</i><br><br>Key characteristics:<br>- Quick execution (5-30 mins)<br>- Focuses on <i>critical path</i> functionality<br>- Often automated as part of CI/CD pipelines",
		"tags": ["testing"],
		"difficulty": "easy",
		"importance": "very rare"
	},
	{
		"type": "multi_select",
		"question": "Which conditions must be met for a deadlock to occur?",
		"answers": [
		"Mutual exclusion (resource cannot be shared)",
		"Hold and wait (process holds resources while waiting for others)",
		"No preemption (resources cannot be forcibly taken)",
		"Circular wait (cyclic dependency between processes)",
		"Automatic garbage collection",
		"Thread priority inversion"
		],
		"correctIndices": [0, 1, 2, 3],
		"explanation": "All <b>four Coffman conditions</b> must simultaneously exist for deadlock:<br><br>1) <b>Mutual Exclusion</b>: Only one process can use a resource at a time<br>2) <b>Hold and Wait</b>: Process holds resources while waiting for others<br>3) <b>No Preemption</b>: Resources cannot be forcibly taken<br>4) <b>Circular Wait</b>: Process A waits for B, which waits for A (cycle)<br><br>Garbage collection and priority inversion are unrelated.",
		"tags": ["concurrency", "threading"],
		"difficulty": "hard",
		"importance": "standard"
	},
	{
		"type": "multi_select",
		"question": "Which strategies help prevent deadlocks?",
		"answers": [
		"Allowing resource preemption",
		"Requiring all threads request resources simultaneously",
		"Using timeout periods for lock acquisition",
		"Establishing a global ordering for lock acquisition",
		"Increasing thread priorities uniformly"
		],
		"correctIndices": [0, 1, 2, 3],
		"explanation": "Deadlock prevention techniques:<br>- <b>Preemption</b>: Forcefully take resources<br>- <b>Atomic requests</b>: Acquire all resources at once<br>- <b>Timeouts</b>: Fail instead of waiting indefinitely<br>- <b>Lock ordering</b>: Consistent acquisition sequence<br>Thread priority doesn't affect deadlock probability.",
		"tags": ["concurrency", "threading"],
		"difficulty": "hard",
		"importance": "rare"
	},
	{
		"type": "multi_select",
		"question": "Which scenarios can lead to thread starvation?",
		"answers": [
		"Low-priority threads competing with high-priority threads",
		"Poorly designed locking mechanisms causing indefinite waits",
		"Fair scheduling policies with equal time allocation",
		"Threads with equal priority accessing CPU-bound resources",
		"Resource leaks in the application"
		],
		"correctIndices": [0, 1],
		"explanation": "Starvation occurs when threads:<br>- Have <b>low priority</b> vs higher-priority competitors<br>- Face <b>unfair scheduling</b> (e.g., always favoring certain locks)<br><br>Equal priority/scheduling or resource leaks don't inherently cause starvation.",
		"tags": ["concurrency", "threading"],
		"difficulty": "medium",
		"importance": "standard"
	},
	{
		"type": "multiple_choice",
		"question": "In .NET, how does a Task differ from a Thread?",
		"answers": [
		"A Task always represents a foreground operation",
		"A Task is a higher-level abstraction that may use threads internally",
		"Threads can be reused across Tasks but not vice versa",
		"Tasks are limited to CPU-bound work only"
		],
		"correctIndices": [1],
		"explanation": "Key differences:<br>- <b>Task</b>: Work unit (async/await, uses thread pool)<br>- <b>Thread</b>: OS-level worker<br>Tasks are <i>background</i> by default and can handle I/O-bound work.",
		"tags": [".net", "concurrency", "threading"],
		"difficulty": "medium",
		"importance": "standard"
	},
	{
		"type": "text_input",
		"question": "What concurrency bug occurs specifically when the correctness of a program depends on the relative timing of threads accessing shared data, leading to inconsistent results?",
		"correctAnswers": ["race condition", "race-condition", "race_condition"],
		"explanation": "A <b>race condition</b> strictly requires:<br>1) Shared mutable state<br>2) No synchronization<br>3) Outcome depends on thread scheduling order<br><br>Not to be confused with:<br>- <b>Deadlock</b> (threads blocked waiting)<br>- <b>Data race</b> (simultaneous unsynchronized access)<br>- <b>Starvation</b> (threads prevented from executing)",
		"tags": ["concurrency", "threading"],
		"difficulty": "medium",
		"importance": "standard"
	},
	{
		"type": "multiple_choice",
		"question": "Which scenario describes a true race condition?",
		"answers": [
		"Two threads simultaneously increment a counter without locks, causing lost updates",
		"Thread A holds Lock 1 and waits for Lock 2, while Thread B does the opposite",
		"A low-priority thread never gets CPU time",
		"A thread crashes when accessing a null reference"
		],
		"correctIndices": [0],
		"explanation": "<b>Race condition</b> (Answer 1): Timing-dependent correctness issue<br><b>Deadlock</b> (Answer 2): Circular waiting<br><b>Starvation</b> (Answer 3): Resource denial<br><b>NullReferenceException</b> (Answer 4): Basic runtime error",
		"tags": ["concurrency", "threading"],
		"difficulty": "easy",
		"importance": "standard"
	},
	{
		"type": "info",
		"question": "Synchronization types/mechanisms overview",
		"explanation": "<br>- Lock: private object syncObject = new object();lock(syncObject);. Can only be used by a single process.<br>- Mutex: Is basically a lock but can also be used across multiple processes.<br>- Semaphore: Allows multiple threads to access a limited number of resources or permits.<br>- EventWaitHandle (AutoResetEvent & ManualResetEvent): Allows threads to communicate by signaling.<br>- ReaderWriterLockSlim: Optimized for multiple reads and occasional writes.<br>- SpinLock: A lock that uses busy-wait rather than blocking on a context switch. For example a while loop that checks some expression to equal true before entering the critical code section within the non-blocking-thread.<br>- CountdownEvent: Allows threads to wait until a specified count has been reached.<br>- Barrier: Allows multiple threads to coordinate and wait at a certain point.<br>- Interlocked: Provides atomic operations for variables.<br>- Volatile: Ensures that a specific variable is always read from its location in memory rather than being cached by the thread.<br><img src=\"img/questions/SynchronizationMechanisms.jpg\">",
		"tags": ["c#", "concurrency", "threading"],
		"difficulty": "hard",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is the core idea behind the Dependency Inversion Principle (DIP)?",
		"answers": [
		"High-level modules should depend on low-level modules",
		"Both high-level and low-level modules should depend on abstractions",
		"Dependencies should be hardcoded for maximum efficiency",
		"Classes should never depend on interfaces"
		],
		"correctIndices": [1],
		"explanation": "The <b>Dependency Inversion Principle</b> states:<br>1) High-level modules should <i>not</i> depend on low-level modules. Both should depend on <b>abstractions</b> (interfaces/abstract classes)<br>2) Abstractions should not depend on details. Details should depend on abstractions<br><br>This enables loose coupling and easier maintenance.",
		"tags": ["design-principle", "theory"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "multi_select",
		"question": "Which techniques implement Dependency Inversion in practice?",
		"answers": [
		"Constructor injection of interfaces",
		"Direct instantiation of concrete classes in business logic",
		"Using service locator pattern",
		"Programming against interface abstractions",
		"Making all class members public for flexibility"
		],
		"correctIndices": [0, 3],
		"explanation": "Proper DIP implementation involves:<br>- <b>Dependency Injection</b> (passing abstractions via constructors/methods)<br>- <b>Interface-based design</b><br><br>Avoid:<br>- Tight coupling to concretions (Answer 2)<br>- Service locator (anti-pattern that hides dependencies)<br>- Breaking encapsulation (Answer 5)",
		"tags": ["design-pattern", "theory"],
		"difficulty": "medium",
		"importance": "essential"
	},
	{
		"type": "info",
		"question": "Microservice patterns overview",
		"explanation": "<br><b>Service Discovery</b><br>A mechanism that enables automatic detection and tracking of instances or locations of microservices in a distributed system, simplifying network configurations and communications.<br>There’s client-side discovery and server-side discovery. With client-side discovery the client itself must (de)register itself; with server-side discovery there usually a third party or another application that handles the (de)registrations.<br><br><b>API Gateway</b><br>A server/application (in my case usually an EF Core backend) that acts as an intermediary for requests from clients, routing them to the appropriate microservices, and aggregating the results, providing a single entry point for external consumers.<br><br><b>Circuit Breaker</b><br>Purpose: Detect continuous failures and prevent the system from repeatedly making calls that are likely to fail.<br>A design pattern that monitors for failures and \"trips\" to temporarily halt operations, preventing continuous strain on a system and allowing recovery or graceful degradation. In C# you could use the NuGet Polly for that.<br><br><b>Bulkhead</b><br>Purpose: Isolate failures and protect the system from cascading failures.<br>A design pattern used in microservices architectures that isolates failures by partitioning the system into components or modules, ensuring that a failure in one part won't overwhelm and crash the entire system, much like watertight compartments in a ship prevent it from sinking if one compartment floods.<br>In C# you could use the NuGet Polly for that.<br><br><b>Saga</b><br>A design pattern in microservices architectures used to manage long-running and complex business transactions by breaking them down into a series of smaller, isolated transactions, ensuring data consistency across services without relying on traditional distributed transactions.<br><br><b>Command Query Responsibility Segregation (CQRS)</b><br>A design pattern where the data modification operations (commands) are separated from the data retrieval operations (queries), often allowing them to scale and evolve independently.<br><br><b>Event-Driven Architecture (EDA)</b><br>A design paradigm where software components produce, detect, and react to events, enabling decoupled, scalable, and asynchronous interactions among components or services. For C# this would likely mean that you would use EventHandlers with += and -= for subscribing and unsubscribing.<br><br><b>Decomposition</b><br>The process of breaking down a complex system or problem into smaller, more manageable parts, often used in software design to transform monolithic applications into modular microservices.<br><br><b>Centralized Configuration</b><br>A practice where configuration settings for multiple services or applications are stored and managed in a single, central location, enabling consistent configuration across services and easier updates or changes.<br><br><b>Log Aggregation</b><br>The process of collecting and centralizing log data from multiple sources, allowing for easier monitoring, analysis, and troubleshooting in distributed systems.<br><br><b>Health Check API</b><br>A Health-Check API is an endpoint in a system that provides information about the operational status and health of the service or application. For example <i>http://localhost:5000/health</i> could return a status response like “Database is running!”.<br><br><b>Blue-Green Deployment</b><br>A deployment strategy where two production environments (blue for the current version and green for the new one) are maintained, allowing for instant rollback and zero-downtime releases by switching traffic between them.<br><br><b>Canary Release</b><br>A deployment strategy where a new software version is introduced to a small subset of users before a full rollout, allowing for real-world testing and early problem detection.",
		"tags": ["microservice", "microservice-pattern", "design-pattern"],
		"difficulty": "hard",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is the primary purpose of a canary release in software deployment?",
		"answers": [
		"To deploy new features to all users simultaneously",
		"To roll out changes to a small subset of users before full deployment",
		"To revert all changes if any bug is detected",
		"To test software in a development environment only"
		],
		"correctIndices": [1],
		"explanation": "A <b>canary release</b> gradually rolls out new features to a small percentage of users (like miners using canaries to detect gas leaks). This allows:<br>- Real-world testing with minimal risk<br>- Monitoring performance/errors before full rollout<br>- Quick rollback if issues arise<br><br>Contrast with blue-green deployments (all-or-nothing switch).",
		"tags": ["devops", "deployment", "continuous-delivery", "microservice", "microservice-pattern", "design-pattern"],
		"difficulty": "easy",
		"importance": "essential"
	},
	{
		"type": "multiple_choice",
		"question": "What is a key difference between an array and a linked list?",
		"answers": [
			"Arrays have fixed sizes, while linked lists can grow dynamically",
			"Linked lists are stored in contiguous memory, while arrays are not",
			"Arrays allow O(1) random access, while linked lists require O(n) traversal",
			"Linked lists always use less memory than arrays"
		],
		"correctIndices": [0, 2],
		"explanation": "Arrays have a fixed size (unless resized, which is costly) and allow O(1) random access. Linked lists can grow dynamically but require O(n) traversal to access elements. Arrays use contiguous memory, while linked lists use scattered memory with node links.",
		"tags": ["theory", "fundamental"],
		"difficulty": "easy",
		"importance": "standard"
	},
	{
		"type": "multiple_choice",
		"question": "Linked lists provide faster random access than arrays.",
		"answers": ["true", "false"],
		"allowAnswerShuffling": false,
		"correctIndices": [1],
		"explanation": "False. Arrays provide O(1) random access, while linked lists require O(n) traversal to reach a specific element.",
		"tags": ["data-structures", "linked-lists", "arrays"],
		"difficulty": "easy",
		"importance": "rare"
	},
	{
		"type": "multiple_choice",
		"question": "What is the main difference between compiled and interpreted languages?",
		"answers": [
			"Compiled languages are always faster than interpreted languages",
			"Compiled languages are translated before execution, while interpreted languages are translated at runtime",
			"Interpreted languages produce standalone executable files",
			"Compiled languages cannot be cross-platform"
		],
		"correctIndices": [1],
		"explanation": "The main difference is when the translation to machine code occurs. Compiled languages are converted to machine code before execution (ahead of time), while interpreted languages are translated line by line during runtime.",
		"tags": ["theory", "fundamental"],
		"difficulty": "easy",
		"importance": "important"
	},
	{
		"type": "multiple_choice",
		"question": "What are the four pillars of Object-Oriented Programming (OOP)?",
		"answers": [
			"Inheritance, Polymorphism, Abstraction, Encapsulation",
			"Classes, Objects, Methods, Attributes",
			"Functions, Loops, Conditionals, Recursion",
			"Stacks, Queues, Trees, Graphs"
		],
		"correctIndices": [0],
		"explanation": "The four pillars of OOP are <b>Inheritance</b>, <b>Polymorphism</b>, <b>Abstraction</b>, and <b>Encapsulation</b>. These principles define how objects interact and structure code in many OOP languages.",
		"tags": ["theory", "oop"],
		"difficulty": "easy",
		"importance": "important"
	},
	{
		"type": "multi_select",
		"question": "What are the key differences between HashSet<T> and List<T> in C#?",
		"answers": [
			"HashSet<T> enforces unique elements while List<T> allows duplicates",
			"List<T> maintains insertion order while HashSet<T> does not",
			"HashSet<T> provides O(1) lookup time for Contains() operations",
			"List<T> supports indexed access while HashSet<T> does not",
			"HashSet<T> is generally slower for membership testing <i>(=checking whether a specific element exists in a collection)</i> than List<T>"
		],
		"correctIndices": [0, 1, 2, 3],
		"explanation": "Key differences:<br>- <b>Uniqueness</b>: HashSet enforces it, List doesn't<br>- <b>Ordering</b>: List preserves insertion order<br>- <b>Performance</b>: HashSet has O(1) Contains() vs List's O(n)<br>- <b>Access</b>: List supports indexers (e.g., list[0])<br>Note: HashSet is faster for membership testing (last option is false).",
		"tags": ["c#", "generics", "collections"],
		"difficulty": "medium",
		"importance": "important"
	}
]